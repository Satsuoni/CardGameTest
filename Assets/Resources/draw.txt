condition countHand
{
count HAND
      condition { true }
      condition { less _count 7 }
}
condition hasID
{
isset playerID
}
condition hasNoID
{
inverse
isset playerID
}

condition countDeck
{
and { condition {

count DECK
 condition { true }
condition { le _count 0 } }

condition {
count DISCARD
condition { true }
condition { greater _count 0 } }
}

}

condition PlayerHands
{
any _Game._Players countHand
}

condition PlayerIDs
{
any _Game._Players hasNoID
}

condition PlayerDecks
{
any _Game._Players countDeck
}

conditional Card
{
tag CARD
string _cardName "not_set"
string _cardText "not_set"
string _cardImage "_"
}

conditional Ability Card
{
tag ABILITY
float _cost 0
string sourceType ATTACK_EDGE
float delay 0.2
function _effects { }
condition _targetCond { and { condition { tag CARD } condition { tag BODY }  } }
condition _castCond { less _cost _Owner.Energy }
}

conditional Transform Card
{
tag TRANSFORM
float _castCost 0
float _maintenanceCost 0
float _dismissCost 0
float _durability 10
list _addedRules { }
list abilities { }
}

conditional Card1 Card
{
string _cardName "Name1"
string _cardText "Test card 1"
string _cardImage "banan"
}

conditional Card2 Card
{
string _cardName "Name__2"
string _cardText "Test card 2!"
string _cardImage "bakabel"
}

conditional CardSampleHead Transform
{
string _cardName "Sample Head"
string _cardText "This is example head
transform"
string _cardImage "bd"

tag SLOT_HEAD
tag ARTIFICIAL
tag ATTACK_BEAM
tag ATTACK_EDGE
float _castCost 10
float _maintenanceCost 5
float _dismissCost 40
float _durability 100

list _addedRules { }
list abilities {
 conditional ab1 Ability
{ condition _targetCond { and { condition { tag CARD } condition { tag BODY }  condition { strcomp |-._distance MELEE }  } }
float _cost 4
function _effects { sub _target.Energy 25 }
}
  }



}

conditional Player
{
list HAND
{ }
list DECK
{
Card1
Card2
Card1
Card2
Card1
Card1
Card2

}
list DISCARD
{ Card1 Card2 }


}

list CARDS
{ }


conditional Player1 Player
{ }

conditional Player2 Player
{ }

list _Players
{
Player1
Player2
}


condition forDismissal
{
and {
 condition { tag BODY }
 condition { tag TRANSFORM }
condition { or { condition  { le Energy 0 } condition { tag DISMISS_MARK } } }
}

}

condition anyToDismiss
{
any _Game._Entities forDismissal
}

conditional dismissRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition anyToDismiss
function _commands 
  {
  accumulate forDismissal _Game._Entities _dismissQueue
  foreach _dismissQueue
   {
   tag_remove _target BODY
   foreach _target.abilities
  {
  remove _Game._Entities _target
  }
   sub _target._Owner.Energy <=_target._dismissCost
   shift _target._Owner.HAND _discard
   tag_switch _discard HAND DISCARD
   push _target._Owner.DISCARD _discard
   hook discard _discard
   push _target._Owner.HAND _target
   set _target.Energy 0
   tag_set _target HAND
   hook tohand _target
   }
  clear _dismissQueue
 }
}

conditional drawRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition PlayerHands
function _commands
{
while PlayerHands
{
accumulate countHand _Game._Players _tmpl
foreach _tmpl
{
any _target.DECK _tmp
remove _target.DECK _tmp
hook draw _tmp
push _target.HAND _tmp

}
clear _tmpl }
}
}


conditional idRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition PlayerIDs
function _commands
{
 accumulate hasNoID _Game._Players _tmpl
 foreach _tmpl
 {
 hook id _target
 }
 clear _tmpl
 }
}

conditional getMainPlayer
{
tag MAIN_RULE
tag INVIOLATE
condition _condition { inverse isset _Game.mainPlayer }
function _commands
{
choice getMainPlayer _Game._Players _Game.mainPlayer
}
}


conditional shuffleRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition PlayerDecks
function _commands
{
 accumulate countDeck _Game._Players _tmpl
 foreach _tmpl
 {
  set DECK <=_target.DISCARD
  clear _target.DISCARD
  newlist _target.DISCARD
  hook shuffle _target
 }
 clear _tmpl
}
}

condition playerReady
{
and
 {
 countHand
 hasID
 }
}

condition playersReady
{
all _Game._Players playerReady
}


condition mainPlayerCanPlay
{

and {
    playersReady
    condition  {  isset _Game.mainPlayer }

    }

}
condition activeAbility
{
and { condition { tag ABILITY }
      condition { tag HAND }
      condition { any _Owner.BODY condition{ and { condition {tag <=<<.sourceType } condition { tag FREE } } } }
      condition { self _hasTargets }
    }
}

condition handTransform
{
and {
condition { tag HAND }
condition { all _Owner.BODY condition{ and { condition {tag <=<<.sourceType } condition { tag FREE } } } }

}
}

condition bodyTransform
{
and {
condition { tag BODY }
condition { tag FREE }
condition { self _executeCondition }

}
}

condition activeTransform
{
and { condition { tag TRANSFORM }
condition { or{
  handTransform
bodyTransform } }
    }
}

condition mpActiveCard
{
and {
   condition { tag MAIN_PLAYER }
condition { or { activeAbility activeTransform } }
    }
}

conditional choiceRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition mainPlayerCanPlay
function _commands
  {
  target mpActiveCard _Game.CARDS
  clear _mpCards
  foreach _targetList
  {

  }
  choice chooseCard _playableCards _Game.mainPlayer.chosenCard
  }
}


list _effects
{
idRule
getMainPlayer
drawRule
shuffleRule
dismissRule
}
list _Entities
{

}
