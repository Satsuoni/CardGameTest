
conditional dismissRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition anyToDismiss
function _commands 
  {
  accumulate forDismissal _Game._Entities _dismissQueue
  foreach _dismissQueue
   {
   tag_remove _target BODY
   foreach _target.abilities
  {
  remove _Game._Entities _target
  }
   sub _target._Owner.Energy <=_target._dismissCost
   shift _target._Owner.HAND _discard
   tag_switch _discard HAND DISCARD
   push _target._Owner.DISCARD _discard
   hook discard _discard
   push _target._Owner.HAND _target
   set _target.Energy 0
   tag_set _target HAND
   hook tohand _target
   }
  clear _dismissQueue
 }
}

conditional drawRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition PlayerHands
function _commands
{
while PlayerHands
{
accumulate countHand _Game._Players _tmpl
foreach _tmpl
{
any _target.DECK _tmp
remove _target.DECK _tmp
push _target.HAND _tmp
tag_switch _tmp DECK HAND
hook draw _tmp

}
clear _tmpl }
}
}

conditional activateRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition { inverse or { DidSelectCard } }
function _commands
{
foreach _Game._Players
{
accumulate condition { and { notCastableTransform condition { tag ACTIVE } } } _target.HAND _todeacc
foreach _todeacc
 {
 tag_remove _target ACTIVE
 }

accumulate condition { and { castableTransform condition { inverse tag ACTIVE } } } _target.HAND _toacc
foreach _toacc
 {
 tag_set _target ACTIVE
 }
}

}
}


conditional ownRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition { any _Game._Players PlayerHasUnownedCards }
function _commands
{
accumulate PlayerHasUnownedCards _Game._Players _tmpl
foreach _tmpl
{
set _tmp <=_target
foreach _target.DECK
{
tag_set _target DECK
set _target._Owner <=_tmp

}
foreach _target.BODY
{
tag_set _target BODY
set _target._Owner <=_tmp

}
clear _tmp
}
clear _tmpl
}
}


conditional idRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition PlayerIDs
function _commands
{
 accumulate hasNoID _Game._Players _tmpl
 foreach _tmpl
 {
 hook id _target
 }
 clear _tmpl
 }
}

conditional getMainPlayer
{
tag MAIN_RULE
tag INVIOLATE
condition _condition { inverse isset _Game.mainPlayer }
function _commands
{
choice getMainPlayer _Game._Players _Game.mainPlayer
}
}


conditional shuffleRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition PlayerDecks
function _commands
{
 accumulate countDeck _Game._Players _tmpl
 foreach _tmpl
 {
  set DECK <=_target.DISCARD
  clear _target.DISCARD
  newlist _target.DISCARD
  hook shuffle _target
 }
 clear _tmpl
}
}

condition playerReady
{
and
 {
 countHand
 hasID
 }
}

condition playersReady
{
all _Game._Players playerReady
}


condition mainPlayerCanPlay
{

and {
    playersReady
    condition  {  isset _Game.mainPlayer }

    }

}
condition activeAbility
{
and { condition { tag ABILITY }
      condition { tag HAND }
      condition { any _Owner.BODY condition{ and { condition {tag <=<<.sourceType } condition { tag FREE } } } }
      condition { self _hasTargets }
    }
}

condition handTransform
{
and {
condition { tag HAND }
condition { all _Owner.BODY condition{ and { condition {tag <=<<.sourceType } condition { tag FREE } } } }

}
}

condition bodyTransform
{
and {
condition { tag BODY }
condition { tag FREE }
condition { self _executeCondition }

}
}

condition activeTransform
{
and { condition { tag TRANSFORM }
condition { or{
  handTransform
bodyTransform } }
    }
}

condition mpActiveCard
{
and {
   condition { tag MAIN_PLAYER }
condition { or { activeAbility activeTransform } }
    }
}

conditional choiceRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition mainPlayerCanPlay
function _commands
  {
  target mpActiveCard _Game.CARDS
  clear _mpCards
  foreach _targetList
  {

  }
  choice chooseCard _playableCards _Game.mainPlayer.chosenCard
  }
}

conditional fillEntitiesRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition { any _Game condition { inverse tag ENTITIES_DONE }  }
function _commands
  {

  newlist _Game._Entities  
  foreach _Game._Players
   {
   push _Game._Entities  _target
   set _tmp <=_target
   foreach _target.DECK
     {
     push _Game._Entities  _target
     }
   foreach _target.DEFAULT_BODY
     {
     push _tmp.BODY _target
     push _Game._Entities  _target
     }
   }
  push _Game._Entities  DistanceTicker 
  push _Game._Entities  DistanceTickerMelee 
  push _Game._Entities  DistanceTickerMid
  push _Game._Entities  DistanceTickerFar
  push _Game._Entities  Timeline 
  set _Game.mainPlayer <=_Game.Player1
  tag_set _Game ENTITIES_DONE
  }
}



conditional deselectRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition DidSelectCard  
function _commands
  {
if _Game.SELECTED condition { tag DESELECT } 
 {
accumulate condition { tag TARGETABLE } _Game._Entities _detarget
 foreach _detarget
 {
 tag_remove _target TARGETABLE
 }
 clear _detarget
tag_remove _Game.SELECTED DESELECT
clear _Game.SELECTED
 } 
  }
 
}

conditional highlightTargetsOfSelectedRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition DidSelectCard
function _commands
  {

 tag_set _Game.SELECTED SEL
 accumulate condition { and {condition { tag ACTIVE } condition { inverse tag SEL } } } _Game._Entities _deacc
 foreach _deacc
 {
 tag_remove _target ACTIVE
 }
 tag_remove _Game.SELECTED SEL
 clear _deacc
 accumulate condition { tag TARGETABLE } _Game._Entities _detarget
 foreach _detarget
 {
 if _target condition { inverse or { isTargetOfSelected } }
  { tag_remove _target TARGETABLE }
 } 
 clear _detarget
 accumulate isTargetOfSelected _Game._Entities _sel
 foreach _sel
 {
 tag_set _target TARGETABLE
 }
   clear _sel

  }
}

function transform_cast
{
 accumulate condition { any <<.castSource condition { tag <=<<.slot } } castTarget._Owner.BODY _remFromBody
 foreach _remFromBody
 {
  tag_remove _target BODY
  tag_remove _target BUSY
  remove castTarget._Owner.BODY  _target
 }
 tag_remove castSource HAND
 remove castSource._Owner.HAND castSource
 tag_set castSource BODY
 push castSource._Owner.BODY castSource
 hook transformation _target
}

conditional castTransformToBodyRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition isTransformCastPrepared
function _commands
  {
  set castPlayer <=|-.SELECTED._Owner
  sub castPlayer.Energy <=|-.SELECTED._castCost 
  clear event 
  new event
  set event._Owner <=|-.SELECTED._Owner
  set event.Delay 0
  set event.castSource <=|-.SELECTED
  set event.castTarget <=|-.TARGETED
  set event.func  <=|-.transform_cast
  tag_remove |-.TARGETED FREE
  tag_set |-.TARGETED BUSY
  tag_set |-.SELECTED BUSY
  insert event |-.Events Delay
  tag_set |-.SELECTED DESELECT
  clear |-.TARGETED
  
  }
}

conditional updateTimeRule
{
tag MAIN_RULE
tag INVIOLATE
condition _condition { any _Game condition { tag UPDATE_TIME } }
function _commands
 {
 newlist cleanEvents
 foreach _Game.Events
 {
  set dtime <=_target._Owner.timeflow
  mul dtime <=_Game.deltaTime
  sub _target.Delay <=dtime
  if _target leDelayZero 
   {
   execute _target <=_target.func
   push cleanEvents _target
    }
 }
foreach cleanEvents
{
remove _Game.Events _target
}
clear cleanEvents
 tag_remove _Game UPDATE_TIME
 }
}

